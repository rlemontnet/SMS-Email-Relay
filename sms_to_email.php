<?php
/************************************************************************/
// SMS To Email
// Take inbound SMS and forward the body as an email
// We are using Mailgun.com to host MX records and handle email for us
// Usage: 
//  File "contacts.csv" must be in same directory as this script. 
//  format of CSV is "e.164 formated phone number","email"
//  example: +15554442222,admin@mydomain.com

require __DIR__ . '/vendor/autoload.php';
require_once('credentials.php');
use Mailgun\Mailgun;
use Nyholm\Psr7\Factory\Psr17Factory;
use Http\Adapter\Guzzle7\Client as GuzzleAdapter;



/************************************************************************/
// Credentials
//
// If you did not define() these in your credentials.php file, then 
// fill them in here.

if (!defined('BANDWIDTH_USER_ID')) {
    define('BANDWIDTH_USER_ID',     'u-xxxxxxxxxxxxxxxxxxxxxxx');    
    define('BANDWITH_API_TOKEN',    't-xxxxxxxxxxxxxxxxxxxxxxx');
    define('BANDWITH_API_SECRET',   'xxxxxxxxxxxxxxxxxxxxxxxxx');
    define('BANDWIDTH_API_URL',     "https://api.catapult.inetwork.com/v1/users/" . BANDWIDTH_USER_ID . "/");
}
if (!defined('MAILGUN_KEY')) {
    define('MAILGUN_KEY',           'key-ZZZZZZZZZZZZZZZZZZZZZ');    
}
if (!defined('DOMAIN')) {
    define('DOMAIN',                'sms.mydomain.com');    
}

// Email  <-> Phone Number Lookup Table
// This should be stored in a database.
// For this demo, we will load the data from a CSV
// format: +155544433333,email@mydomain.com
if (file_exists('contacts.csv')) {
    $smsMapping = loadCSV("contacts.csv");
} else {
    error_log("Failed to load contacts.csv");
    die();
}

/************************************************************************/
// Main Application
//
// Process inbound http POST from Bandwidth. Before executing the code, we 
// first check to make sure this is an SMS (or MMS). Then we will relay the
// SMS to email via Mailgun
//
$rest_json = file_get_contents("php://input");
$rest_vars = json_decode($rest_json, true);

if (in_array($rest_vars['type'], array('message-received','message received'))) { // Incoming message
    // Verify that we have a matching email for the "to" number
    if (!lookupEmail($rest_vars['to'])) {
        error_log("No corresponding email for " . $rest_vars['to']);
        die();
    }

    $phoneUtil = \libphonenumber\PhoneNumberUtil::getInstance();
    $emailFields = array(
        'from'    => "SMS " . $phoneUtil->format($phoneUtil->parse($rest_vars['to'], "US"),
                            \libphonenumber\PhoneNumberFormat::NATIONAL) 
                            . " <" . substr($rest_vars['to'],2) ."@". DOMAIN . ">",
        'to'      => lookupEmail($rest_vars['to']),
        'subject' => $rest_vars['message']['from'],
        'text'    => $rest_vars['message']['text']
        );

    $emailAttachments['attachment'] = array();
    if (isset($rest_vars['media'])) {
        // retreive media and add to array
        $mediaList = getBandwidthMedia($rest_vars['media']);
        $emailAttachments['attachment'] = $mediaList;

        // Often people will send media without corresponding text.
        // Mailgun API gets upset if there is not text / body
        if (empty($rest_vars['message']['text'])) {
            $emailFields['message']['text'] = "Attached";
        }
    }

    // Relay the SMS to email
    $mgClient = Mailgun::create('MAILGUN_KEY');
    $result = $mgClient->messages()->send(DOMAIN, $emailFields,  $emailAttachments);

    // Delete any downloaded attachments
    if (isset($mediaList)) {
        deleteBandwidthMedia ($mediaList);
    }
}

/************************************************************************/
// Supporting Functions
/************************************************************************/

function lookupEmail ($phoneNumber) {
/* Takes a phone number and returns an associated email address
*
* @param string $phoneNumber - e.164 formated phone number
*
* @return string $result - returns email address or 0 if no match is found
*/    
    global $smsMapping;
    return (array_key_exists("$phoneNumber", $smsMapping)) ? $smsMapping[$phoneNumber] : 0;
}

function loadCSV($filename) {
    // Assume there is no header row.
    // Assume we are following the format of:
    // +15554442222,admin@mydomain.com
    $csvArray = array(); 
    if (($handle = fopen($filename, "r")) !== FALSE) {
        while (($row = fgetcsv($handle, 1000, ",")) !== FALSE) {
           $csvArray["$row[0]"] = "$row[1]";
        }
        if (!feof($handle)) {
            error_log("Error: unexpected fgets() fail\n");
        }
    }
    fclose($handle);

    return $csvArray;
}

function getBandwidthMedia ($mediaUris) {
/* Retreive media received from MMS and store locally
*
* @param array $mediaUris() - A list of URIs generated by Bandwidth that points to 
*                   the MMS media. The list is passed from the Message Callback in
                    the 'media' property
* @return array $result() - list of local names of media downloaded.
*/
    foreach ($mediaUris as $key => $value) {
        // Ignore text and smil attachments.
        if (!in_array(substr($value, -4), array("smil", ".txt"))){
           // Pull media
            $ch=curl_init($value);
            curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
            curl_setopt($ch, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);
            curl_setopt($ch, CURLOPT_USERPWD, BANDWIDTH_API_TOKEN . ":" . BANDWIDTH_API_SECRET);
            $data = curl_exec($ch);

            if (!$data) {
                error_log("Failed to download $value");
                error_log(print_r(curl_error($ch),true));
            } 
            
            curl_close($ch);

            $destination = substr(strrchr($value, '/'), 1);
            $file = fopen($destination, "w+");
            fputs($file, $data);
            fclose($file);

            $result[] = $destination;
        }
    }
    return $result;
}
function deleteBandwidthMedia ($files)  {
/* Deletes a list of files that were stored locally
*
* @param array $files() - A list of local files generated by getBandwidthMedia
*/
    foreach ($files as $index => $file) {
        unlink ($file);
    }
}

?>
